_A note for English-speaking followers of this repository: the below is a write-up for the challenges I wrote for a CTF for Russian-speaking participants, so it naturally is in Russian. Use an LLM of you choice to translate if you're interested. :)_

### Введение

В этом году для YaCTF я приготовил три задачи, посвящённые замечательному во всех смыслах проекту [IX](https://stal-ix.github.io/) за авторством Антона Самохвалова. IX &mdash; это пакетный менеджер, который может собрать практически любую программу с открытыми исходникам (от шелла до браузера) в статический бинарник под практически любую платформу. Соответственно, участники в этом году могли насладиться тремя полностью статическими бинарниками, реализующими [известный сетевой протокол из восьмидесятых](https://www.rfc-editor.org/rfc/rfc862.html) с различными уязвимостями, которые нужно было превратить в remote code execution и, как обычно принято, стащить секретный файл с сервера в качестве подтверждения.

Третий бинарник был на языке Rust, который, как мы знаем, является memory-safe, но не совсем. Его за время соревнования так никто и не размочил, и он всё ещё [ждёт](http://ix-platinum.yactf.ru/) своего героя (первому решившему полагается символический приз за это).

Зато первые два бинарника &mdash; на языке C и на языке C++, соответственно, &mdash; за время CTF распечатать успели (ещё раз поздравляю решившие команды!), и в этом разборе речь пойдёт именно про них.

### ASLR

Отдельным параграфом вынесу объяснение про [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization), поскольку во время CTF стало ясно, что не все участники хорошо понимают, как он работает в Linux. Если ничего специально не трогать в современном дистрибутиве, то рандомизация адресного пространства в пространстве пользователя будет устроена примерно так:
  * [база стека главного потока](https://github.com/torvalds/linux/blob/e1afacb68573c3cd0a3785c6b0508876cd3423bc/mm/util.c#L450) всегда будет рандомизирована, и злоумышленнику будет неизвестен её точный адрес.
  * [база `mmap()`](https://docs.kernel.org/admin-guide/sysctl/vm.html#mmap-rnd-bits) тоже всегда будет содержать случайный компонент. Другими словами, хакер не будет знать точных адресов динамически загруженных библиотек, данных, выделенных аллокатором, а также стеков неглавных потоков.
  * а вот для собственно кода самого бинарника рандомизация по понятным причинам будет применяться, [только если он собран как position-independent executable](https://github.com/torvalds/linux/blob/e1afacb68573c3cd0a3785c6b0508876cd3423bc/fs/binfmt_elf.c#L1142) (тип `ET_DYN` в ELF).

Но в IX все бинарники собираются как `ET_EXEC` и загружаются по фиксированному адресу. В целом это логично &mdash; модель безопасности IX не предполагает, что собранные программы будут светить в интернет голой задницей. Тем не менее, задача CTF-участников резко упрощается: проэксплуатировав memory-safety-уязвимость, они могут прыгнуть на любую присутствующую в бинарнике инструкцию, хотя в реальной жизни ещё пришлось бы долго и грустно искать, как победить ASLR.

### IX Echo Server Basic

Идея первой задачи родилась из [поста Антона](https://medium.com/@anton_samokhvalov/static-linking-considered-useful-c25300c46e3d) двухлетней давности. Он совсем коротенький, но для тех, кому лень читать, перескажу основной тезис своими словами: в адресное пространство динамически собранного бинарника попадают фрагменты неиспользуемого кода, из которых злоумышленник может легко насобирать ROP-гаджетов. В статически собранный бинарник попадает только то, что в нём реально используется, поэтому ROP-гаджетов там меньше, и статическая сборка безопаснее.

Это довольно коварное логическое заблуждение (на которое попадаются в том числе и люди, [хорошо разбирающиеся в теме](https://isopenbsdsecu.re/mitigations/rop_removal/)): в контексте построения ROP-цепочек для хакера важно не количество гаджетов, а их качество &mdash; произвольную цепочку можно собрать буквально за единицы хороших гаджетов, а если повезёт, то вообще [за один](https://en.wikipedia.org/wiki/Sigreturn-oriented_programming). То, что статическая сборка оставляет в бинарнике 1000 гаджетов вместо 10000, само по себе ни о чём не говорит.

Вооружённый этой интуицией, я поставил себе задачу: собрать IX-бинарник для x86-64 приемлемых размеров, всё ещё имеющий в себе достаточно жирных гаджетов, чтобы собрать нетривиальный ROP. И... быстро столкнулся с обратной проблемой: как бы я ни уменьшал бинарник, в результирующем файле было столько мусора, что собрать цепочку было до отвращения просто.

Вот неполный список того, что я сделал, пытаясь спасти положение:
  * включил опции сборки/линковки, которые удаляют неиспользуемый код из бинарника (теперь [это добавлено в настройки по умолчанию](https://github.com/pg83/ix/commit/8edc6e213db0bbf450570a8a62c4de89e5758f49))
  * собрал `musl` [в легковесном режиме](https://github.com/pg83/ix/blob/3272e5be004d36bdd1c0e129b690a33ec6e382b4/pkgs/lib/c/ix.sh#L4), чтобы убрать из него мусор, добавляемый в IX по умолчанию
  * вместо функций-обёрток над системными вызовами из `musl` начал дёргать системные вызовы напрямую через инлайн-ассемблер

В конечном счёте ничего из этого не помогло &mdash; оказалось, что в пустом бинарнике с `musl`, который выглядит как `int main() { return 0; }`, всё ещё достаточно гаджетов. В этот момент я решил <s>запить горькую</s> сдаться и собрать задачу из того, что есть &mdash; всё же в пустом бинарнике уже надо было немножко подумать, чтобы собрать цепочку.

Задача была задумана как разминочная, поэтому баг, приводящий к переполнению стека и намазыванию ROP, я выбрал совсем простой: эхо-сервер &ldquo;ради производительности&rdquo; вручную манипулирует размером TCP-буфера через `setsockopt(..., SO_RCVBUF, ...)`, но не учитывает особенность, описанную в документации:

> Sets or gets the maximum socket receive buffer in bytes. The kernel **doubles this value** (to allow space for bookkeeping overhead) when it is set using setsockopt(2), and this doubled value is returned by getsockopt(2).

Это в итоге приводит к переполнению буфера на стеке полностью контролируемым содержимым; остаётся лишь смастерить ROP-цепочку из этого содержимого, которая утаскивает секретный файл и сливает его наружу. В этом месте можно было срезать несколько углов, но пижонства ради я решил всё делать максимально красиво:
  * ROP намазывается так, чтобы получить полноценный примитив `SYSCALL(ARG1, ARG2, ARG3)`, через который уже делается `fd = open("/flag.txt", O_RDONLY); read(fd, buf, size); write(socket_fd, buf, size);`. Эхо-сервер я заточил в песочницу, в которой не было ничего, даже шелла (слава статической сборке, которая делает такое возможным!), поэтому просто сделать `execve("/bin/sh", NULL, NULL)` было нельзя.
  * ROP не может использовать инструкции из `main()` или любой другой функции, которую `main()` вызывает, &mdash; по сути, он должен быть собран из той части `musl`, которая отрабатывает до `main()`, инициализируя `libc`.

Наверное, самый главный рояль в кустах, без которого ничего бы не получилось, спрятан [тут](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/thread/x86_64/__set_thread_area.s#L10). Эта ассемблерная функция используется для [инициализации TLS](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/env/__init_tls.c#L18) и мгновенно даёт гаджет `syscall; ret`, позволяющий сделать произвольный системный вызов.

Дальше нам нужно суметь проконтролировать регистры `rax` (номер системного вызова) и `rdi, rsi, rdx` (аргументы с первого по третий). Гаджеты на `rdi` и `rsi` находит любая искалка типа [ROPGadget](https://github.com/JonathanSalwan/ROPgadget) традиционной техникой:
  * в эпилоге функции `__init_tls()` есть восстановление (callee-saved) регистра `r15` через `pop r15`
  * в эпилоге функции `__init_libc()` есть восстановление (callee-saved) регистра `r14` через `pop r14`
  * обе эти инструкции кодируются двумя байтами, первый из которых &mdash; [REX-префикс](https://en.wikipedia.org/wiki/REX_prefix)
  * если прыгнуть на второй байт, отрезав REX-префикс, то эти инструкции магическим образом превратятся в `pop rdi` и `pop rsi`, что нам и нужно

Гаджет на `rax` найти чуть посложнее, он [притаился](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/string/x86_64/memset.s#L50) внутри ассемблерной реализации `memset()` в виде `mov rax, rdi; ret` (а `rdi` мы уже контролируем). `memset()` неявно [используется](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/env/__libc_start_main.c#L25) внутри `__init_libc()`, и к нему мы ещё вернёмся.

`rdx` требует ещё немного креативности:
  * в эпилоге `__init_tls()` есть `pop r12` и `pop r14`
  * в середине `libc_start_main_stage2()` (которая в итоге позовёт `main()`) есть последовательность `mov rdx, r12; call r14`
  * так как мы контролируем и `r12`, и `r14`, то `rdx` мы теперь контролируем тоже, а `call r14` для нас теперь &mdash; это всё равно что `ret`

Теперь мы умеем делать `SYSCALL(ARG1, ARG2, ARG3)`, и осталось сделать самый нетривиальный шаг, который давался участникам тяжелее всего &mdash; материализовать строку `/flag.txt` по известному адресу, чтобы потом передать её в `open()`. `.bss` бинарника по определению доступен на запись и имеет известный адрес, поэтому куда писать &mdash; ясно. Но вот _откуда_ писать? Адрес стека, к сожалению, мы не знаем (см. секцию про ASLR выше).

Авторское решение использует ещё один гаджет, [спрятанный](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/string/x86_64/memset.s#L48) в недрах `memset()`: `mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx); ...` или, если перевести с богомерзкого AT&T-диалекта на человеческий язык, `mov qword [rdi+rdx-0x27], rax`. `rdi`, `rdx`, `rax` мы контролируем, а значит, несложной арифметикой этот гаджет превращается в примитив &ldquo;запиши заданные 8 байт по заданному адресу&rdquo;. С помощью этого мы можем написать `/flag.txt` в `.bss` и завершить цепочку.

В завершение хотелось бы отметить, что в случае x86-64 на достаточно современных процессорах всю вахканалию с поиском гаджетов можно было бы абсолютно детерминированно пресечь в корне через Intel CET (точнее, через [теневые стеки](https://docs.kernel.org/next/x86/shstk.html)). Но в `musl` поддержки теневых стеков нет и, похоже, не планируется, так что в случае IX так и придётся жить с тем, что любое переполнение стека может превратиться в выполнение произвольного кода.

### IX Echo Server Silver

**TODO**