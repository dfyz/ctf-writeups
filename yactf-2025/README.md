_A note for English-speaking followers of this repository: the below is a write-up for the challenges I wrote for a CTF for Russian-speaking participants, so it naturally is in Russian. Use an LLM of you choice to translate if you're interested. :)_

### Введение

В этом году для YaCTF я приготовил три задачи, посвящённые замечательному во всех смыслах проекту [IX](https://stal-ix.github.io/) за авторством Антона Самохвалова. IX &mdash; это пакетный менеджер, который может собрать практически любую программу с открытыми исходникам (от шелла до браузера) в статический бинарник под практически любую платформу. Соответственно, участники в этом году могли насладиться тремя полностью статическими бинарниками, реализующими [известный сетевой протокол из восьмидесятых](https://www.rfc-editor.org/rfc/rfc862.html) с различными уязвимостями, которые нужно было превратить в remote code execution и, как обычно принято, стащить секретный файл с сервера в качестве подтверждения.

Третий бинарник был на языке Rust, который, как мы знаем, является memory-safe, но не совсем. Его за время соревнования так никто и не размочил, и он всё ещё [ждёт](http://ix-platinum.yactf.ru/) своего героя (первому решившему полагается символический приз за это).

Зато первые два бинарника &mdash; на языке C и на языке C++, соответственно, &mdash; за время CTF распечатать успели (ещё раз поздравляю решившие команды!), и в этом разборе речь пойдёт именно про них.

### ASLR

Отдельным параграфом вынесу объяснение про [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization), поскольку во время CTF стало ясно, что не все участники хорошо понимают, как он работает в Linux. Если ничего специально не трогать в современном дистрибутиве, то рандомизация адресного пространства в пространстве пользователя будет устроена примерно так:
  * [база стека главного потока](https://github.com/torvalds/linux/blob/e1afacb68573c3cd0a3785c6b0508876cd3423bc/mm/util.c#L450) всегда будет рандомизирована, и злоумышленнику будет неизвестен её точный адрес.
  * [база `mmap()`](https://docs.kernel.org/admin-guide/sysctl/vm.html#mmap-rnd-bits) тоже всегда будет содержать случайный компонент. Другими словами, хакер не будет знать точных адресов динамически загруженных библиотек, данных, выделенных аллокатором, а также стеков неглавных потоков.
  * а вот для собственно кода самого бинарника рандомизация по понятным причинам будет применяться, [только если он собран как position-independent executable](https://github.com/torvalds/linux/blob/e1afacb68573c3cd0a3785c6b0508876cd3423bc/fs/binfmt_elf.c#L1142) (тип `ET_DYN` в ELF).

Но в IX все бинарники собираются как `ET_EXEC` и загружаются по фиксированному адресу. В целом это логично &mdash; модель безопасности IX не предполагает, что собранные программы будут светить в интернет голой задницей. Тем не менее, задача CTF-участников резко упрощается: проэксплуатировав memory-safety-уязвимость, они могут прыгнуть на любую присутствующую в бинарнике инструкцию, хотя в реальной жизни ещё пришлось бы долго и грустно искать, как победить ASLR.

### IX Echo Server Basic

Идея первой задачи родилась из [поста Антона](https://medium.com/@anton_samokhvalov/static-linking-considered-useful-c25300c46e3d) двухлетней давности. Он совсем коротенький, но для тех, кому лень читать, перескажу основной тезис своими словами: в адресное пространство динамически собранного бинарника попадают фрагменты неиспользуемого кода, из которых злоумышленник может легко насобирать ROP-гаджетов. В статически собранный бинарник попадает только то, что в нём реально используется, поэтому ROP-гаджетов там меньше, и статическая сборка безопаснее.

Это довольно коварное логическое заблуждение (на которое попадаются в том числе и люди, [хорошо разбирающиеся в теме](https://isopenbsdsecu.re/mitigations/rop_removal/)): в контексте построения ROP-цепочек для хакера важно не количество гаджетов, а их качество &mdash; произвольную цепочку можно собрать буквально за единицы хороших гаджетов, а если повезёт, то вообще [за один](https://en.wikipedia.org/wiki/Sigreturn-oriented_programming). То, что статическая сборка оставляет в бинарнике 1000 гаджетов вместо 10000, само по себе ни о чём не говорит.

Вооружённый этой интуицией, я поставил себе задачу: собрать IX-бинарник для x86-64 приемлемых размеров, всё ещё имеющий в себе достаточно жирных гаджетов, чтобы собрать нетривиальный ROP. И... быстро столкнулся с обратной проблемой: как бы я ни уменьшал бинарник, в результирующем файле было столько мусора, что собрать цепочку было до отвращения просто.

Вот неполный список того, что я сделал, пытаясь спасти положение:
  * включил опции сборки/линковки, которые удаляют неиспользуемый код из бинарника (теперь [это добавлено в настройки по умолчанию](https://github.com/pg83/ix/commit/8edc6e213db0bbf450570a8a62c4de89e5758f49))
  * собрал `musl` [в легковесном режиме](https://github.com/pg83/ix/blob/3272e5be004d36bdd1c0e129b690a33ec6e382b4/pkgs/lib/c/ix.sh#L4), чтобы убрать из него мусор, добавляемый в IX по умолчанию
  * вместо функций-обёрток над системными вызовами из `musl` начал дёргать системные вызовы напрямую через инлайн-ассемблер

В конечном счёте ничего из этого не помогло &mdash; оказалось, что в пустом бинарнике с `musl`, который выглядит как `int main() { return 0; }`, всё ещё достаточно гаджетов. В этот момент я решил <s>запить горькую</s> сдаться и собрать задачу из того, что есть &mdash; всё же в пустом бинарнике уже надо было немножко подумать, чтобы собрать цепочку.

Задача была задумана как разминочная, поэтому баг, приводящий к переполнению стека и намазыванию ROP, я выбрал совсем простой: эхо-сервер &ldquo;ради производительности&rdquo; вручную манипулирует размером TCP-буфера через `setsockopt(..., SO_RCVBUF, ...)`, но не учитывает особенность, описанную в документации:

> Sets or gets the maximum socket receive buffer in bytes. The kernel **doubles this value** (to allow space for bookkeeping overhead) when it is set using setsockopt(2), and this doubled value is returned by getsockopt(2).

Это в итоге приводит к переполнению буфера на стеке полностью контролируемым содержимым; остаётся лишь смастерить ROP-цепочку из этого содержимого, которая утаскивает секретный файл и сливает его наружу. В этом месте можно было срезать несколько углов, но пижонства ради я решил всё делать максимально красиво:
  * ROP намазывается так, чтобы получить полноценный примитив `SYSCALL(ARG1, ARG2, ARG3)`, через который уже делается `fd = open("/flag.txt", O_RDONLY); read(fd, buf, size); write(socket_fd, buf, size);`. Эхо-сервер я заточил в песочницу, в которой не было ничего, даже шелла (слава статической сборке, которая делает такое возможным!), поэтому просто сделать `execve("/bin/sh", NULL, NULL)` было нельзя.
  * ROP не может использовать инструкции из `main()` или любой другой функции, которую `main()` вызывает, &mdash; по сути, он должен быть собран из той части `musl`, которая отрабатывает до `main()`, инициализируя `libc`.

Наверное, самый главный рояль в кустах, без которого ничего бы не получилось, спрятан [тут](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/thread/x86_64/__set_thread_area.s#L10). Эта ассемблерная функция используется для [инициализации TLS](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/env/__init_tls.c#L18) и мгновенно даёт гаджет `syscall; ret`, позволяющий сделать произвольный системный вызов.

Дальше нам нужно суметь проконтролировать регистры `rax` (номер системного вызова) и `rdi, rsi, rdx` (аргументы с первого по третий). Гаджеты на `rdi` и `rsi` находит любая искалка типа [ROPGadget](https://github.com/JonathanSalwan/ROPgadget) традиционной техникой:
  * в эпилоге функции `__init_tls()` есть восстановление (callee-saved) регистра `r15` через `pop r15`
  * в эпилоге функции `__init_libc()` есть восстановление (callee-saved) регистра `r14` через `pop r14`
  * обе эти инструкции кодируются двумя байтами, первый из которых &mdash; [REX-префикс](https://en.wikipedia.org/wiki/REX_prefix)
  * если прыгнуть на второй байт, отрезав REX-префикс, то эти инструкции магическим образом превратятся в `pop rdi` и `pop rsi`, что нам и нужно

Гаджет на `rax` найти чуть посложнее, он [притаился](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/string/x86_64/memset.s#L50) внутри ассемблерной реализации `memset()` в виде `mov rax, rdi; ret` (а `rdi` мы уже контролируем). `memset()` неявно [используется](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/env/__libc_start_main.c#L25) внутри `__init_libc()`, и к нему мы ещё вернёмся.

`rdx` требует ещё немного креативности:
  * в эпилоге `__init_tls()` есть `pop r12` и `pop r14`
  * в середине `libc_start_main_stage2()` (которая в итоге позовёт `main()`) есть последовательность `mov rdx, r12; call r14`
  * так как мы контролируем и `r12`, и `r14`, то `rdx` мы теперь контролируем тоже, а `call r14` для нас теперь &mdash; это всё равно что `ret`

Теперь мы умеем делать `SYSCALL(ARG1, ARG2, ARG3)`, и осталось сделать самый нетривиальный шаг, который давался участникам тяжелее всего &mdash; материализовать строку `/flag.txt` по известному адресу, чтобы потом передать её в `open()`. `.bss` бинарника по определению доступен на запись и имеет известный адрес, поэтому куда писать &mdash; ясно. Но вот _откуда_ писать? Адрес стека, к сожалению, мы не знаем (см. секцию про ASLR выше).

Авторское решение использует ещё один гаджет, [спрятанный](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/string/x86_64/memset.s#L48) в недрах `memset()`: `mov %rax,(-1-2-4-8-16-8)(%rdi,%rdx); ...` или, если перевести с богомерзкого AT&T-диалекта на человеческий язык, `mov qword [rdi+rdx-0x27], rax`. `rdi`, `rdx`, `rax` мы контролируем, а значит, несложной арифметикой этот гаджет превращается в примитив &ldquo;запиши заданные 8 байт по заданному адресу&rdquo;. С помощью этого мы можем написать `/flag.txt` в `.bss` и завершить цепочку.

В завершение хотелось бы отметить, что в случае x86-64 на достаточно современных процессорах всю вахканалию с поиском гаджетов можно было бы абсолютно детерминированно пресечь в корне через Intel CET (точнее, через [теневые стеки](https://docs.kernel.org/next/x86/shstk.html)). Но в `musl` поддержки теневых стеков нет и, похоже, не планируется, так что в случае IX так и придётся жить с тем, что любое переполнение стека может превратиться в выполнение произвольного кода.

### IX Echo Server Silver

Вторая задача тоже родилась из [другого поста Антона](https://medium.com/@anton_samokhvalov/rustless-sudo-exploring-secure-alternatives-for-suid-binaries-4e46391de292) с весьма провокационным советом <s>стрелять себе в ногу</s> выкатывать в продакшен бинарники, собранные с [AddressSanitizer](https://github.com/google/sanitizers/wiki/addresssanitizer), чтобы обеспечить memory safety (чисто технически в посте речь идёт только о suid'ных бинарниках, но при желании этот совет можно применить куда угодно).

Чтобы понять, что так делать не стоит, можно посмотреть на:
  * [официальную документацию](https://clang.llvm.org/docs/AddressSanitizer.html#security-considerations) к AddressSanitizer, встроенному в clang (в контексте IX нас интересует именно он)
  * лаконичное и доходчивое [теоретическое объяснение](https://lobste.rs/s/ngg64e/rustless_sudo_running_some_suid_binaries#c_yzomel) модели работы AddressSanitizer от Дэвида Чиснала ([руководителя проекта CHERIoT](https://cheri-alliance.org/events/speakers/david-chisnall/), среди прочих регалий)
  * [наглядную визуальную демонстрацию](https://x.com/filpizlo/status/1976831020566798656) от автора [Fil-C](https://fil-c.org/)

Если же переходить в более практическую плоскость, то можно вспомнить [задачу](https://hxp.io/blog/118/hxp-38C3-CTF-suboptimal_pwning/) с hxp CTF прошлого года, где нужно было проэксплуатировать бинарник с тривиальным переполнением стека, но собранный со всеми модными митигациями, включая AddressSanitizer. Мне же хотелось сделать задачу с более ограниченным и интересным багом, и после нескольких экспериментом я остановился на таком варианте:
  * эхо-сервер &ldquo;для производительности&rdquo; в цикле вызывает `read()`, пока в сокете есть данные для чтения. Наличие данных проверяется через `select()`.
  * между чтениями указатель на буфер в памяти сдвигается на количество прочитанных байт &mdash; то есть на результат, который вернул `read()`
  * `read()` также может вернуть `-1`, если что-то пошло не так или если читать из сокета нечего (все сокеты в программе объявлены неблокирующими). В таком случае эхо-сервер пытается аварийно завершить программу, но из-за неудачного использования ключевого слова `auto` из C++ счётчик количества прочитанных байтов объявлен как беззнаковая переменная вместо знаковой (**баг!**), и проверка на `-1` никогда не срабатывает.

Таким образом, для эксплуатации нужно каким-то образом заставить `read()` вернуть `-1` после успешного `select()` (тогда мне казалось, что это должно быть просто, но если забегать вперёд, то это оказалось самой сложной частью задачи). После этого мы получим возможность переписать чужие данные слева от буфера и использовать это для чего-то хорошего (для хакера).

Я перебрал несколько вариантов расположения данных в памяти и, чтобы совсем не жестить, сделал одну структуру, в которой слева от буфера лежит указатель на него (в виде `std::span<char>`). В таком случае переход из буфера в указатель считается так называемым intra-object overflow, на который AddressSanitizer не реагирует совсем и который мгновенно даёт примитив write-what-where: переписываем указатель на буфер в `std::span` контролируемыми данными, и при следующем чтении в буфер уже можем перезаписать произвольные данные в памяти, если их адрес известен и они не попали в красную зону AddressSanitizer.

Через такой примитив получить RCE &mdash; уже дело техники. В авторском решении технику я выбрал первую пришедшую в голову:
  * перезаписываем [массив с функциями](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/exit/atexit.c#L15-L20), которые регистрируются с помощью `atexit()` и вызываются на выходе из программы (первый аргумент этих функций мы контролируем).
  * первой функцией прыгаем на [гаджет](https://github.com/kraj/musl/blob/ff441c9ddfefbb94e5881ddd5112b24a944dc36c/src/setjmp/x86_64/longjmp.s#L17) из `longjmp()`, который устанавливает стек (`rsp`) в контролируемое нами фиктивное значение
  * в качестве фиктивного стека указываем адрес из того же массива с функциями
  * и намазываем на этот массив ROP-цепочку &mdash; на этот раз это сделать гораздо проще, чем в первой задаче, потому что бинарник с AddressSanitizer сильно толще, а также потому, что Антон заботливо положил нам [open()](https://github.com/pg83/ix/blob/80e6205d17fc00ebba375dfc2a2d90127dae12f6/pkgs/lib/dlfcn/latest/dlfcn.cpp#L15), на который можно прыгать напрямую вместо обходных манёвров с `SYSCALL(ARG1, ARG2, ARG3)`

Внимательный читатель на этом месте возмутится и спросит, откуда в эхо-сервере вдруг взялся `longjmp()`, ведь IX удаляет весь неиспользуемый код (именно этот вопрос я задал сам себе уже после того, как накатал авторское решение)? Ответ: поддержку AddressSanitizer в IX я добавлял [самостоятельно](https://github.com/pg83/ix/commit/f3a90fb63d77c00d1c65b60d817bc214413f689a), и это последствия того, что я не очень аккуратно [обработал](https://github.com/pg83/ix/blob/b78e85a50f8a3e423541a77fe47066180165c2dd/pkgs/lib/compiler_rt/sanitize/t/ix.sh#L100-L104) функции-перехватчики из AddressSanitizer. В моём варианте они линкуются в каждый бинарник безусловно, и это приводит к тому, что любая функция с объявленным перехватчиком (а `longjmp()` именно такая) тоже безусловно попадёт в конечный бинарник. Подумав немного, я решил оставить всё как есть &mdash; `longjmp()` делает эксплойт короче, но легко можно обойтись и без него. И да, не очень доверяя себе, я на всякий случай проверил, что авторское решение (по модулю ASLR, конечно), работает и с апстримным AddressSanitizer в комбинации &ldquo;Alpine + musl + динамическая сборка&rdquo;.

Казалось бы, дело в шляпе, думал я, придумав вышеописанную технику &mdash; осталось только научиться контролируемо провоцировать ошибку в `read()` после успешного `select()`. И тут вдруг оказалось, что все способы, про которые я исходно думал, не работают:
  * можно заставить `read()` вернуть `ECONNRESET`, послав RST-пакет, но это бессмысленно &mdash; после этого клиент уже не сможет ничего записать в сокет, и контролируемой перезаписи не случится
  * документация по `select()` в прямом виде обещает желаемое следующей цитатой: <q>Under Linux, select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded.</q>. На поверку оказывается, что это обман, по крайней мере в случае TCP, &mdash; проверка контрольной суммы происходит на ранних этапах, задолго до того как пакет имеет шансы дойти до `select()`.
  * `read()` может вернуть `EINTR`, если он был прерван сигналом, но спровоцировать посылку сигнала по сети контролируемым образом почти невозможно &mdash; есть сигнал SIGURG, который был заигран в одном из предыдущих YaCTF, но он требует для корректной работы предварительной настройки, которая в эхо-сервере смотрелась бы неестественно
  * если говорить о SIGURG, то посылка [urgent-данных](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Out-of-band_data) могла бы заставить `read()` вернуть `EAGAIN`, но `select()` при получении таких данных просыпаться отказывался

Здесь, конечно, стоило зафиксировать прибыль и переделать структуру задачи, поменяв баг на какой-то другой, но уже чисто из спортивного интереса я закопался в исходники ядра Linux поплотнее, и всё-таки нашёл способ добиться нужного поведения.

Оказалось, что `select()` не просыпается из-за того, что ядро, задетектив URG-данные, [увеличивает](https://github.com/torvalds/linux/blob/b711733e89a3f84c8e1e56e2328f9a0fa5facc7c/net/ipv4/tcp.c#L582) на единицу счётчик байтов, которые требуются для пробуждения. Функция, которая может спровоцировать пробуждение, [считает](https://github.com/torvalds/linux/blob/b711733e89a3f84c8e1e56e2328f9a0fa5facc7c/include/net/tcp.h#L1691), что одного доступного байта недостаточно, и продолжает спать. Однако в этой же функции есть ещё одно условие: можно внепланово пробудиться, если сработал `tcp_rmem_pressure()` (то есть если сокет потребляет много памяти на свои пакеты &mdash; хотя бы [7/8 от максимума](https://github.com/torvalds/linux/blob/b711733e89a3f84c8e1e56e2328f9a0fa5facc7c/include/net/tcp.h#L1666)). Контролируемо прийти в такую ситуацию через стандартное TCP-общение нельзя (точнее, я не придумал как; возможно, кто-то придумает), но через сырые сокеты можно заслать множество однобайтовых TCP пакетов с дырками (то есть если сервер хочет байт с номером N, то послать байты N + 2, N + 4, ...), и они осядут в очереди, в которой накапливаются пакеты, которые пока что невозможно отдать читателю сокета, сожрав сколько угодно памяти.

Приведя сокет в такое печальное состояние, дальше мы засылаем URG-байт с номером N, сервер просыпается из `select()` из-за давления на память, но прочитать ничего не может, и `read()` возвращает `EAGAIN`. Сделав так несколько раз и выехав на просторы указателя на буфер, потом мы можем просто дослать недостающие пакеты и обычными байтами доделать свои грязные дела.

Хотя этот трюк никак не относится к образовательной сути задачи (показать, что не надо гонять AddressSanitizer в проде), он мне так понравился (и его не смогла найти ни одна топовая ллмка), что я решил оставить задачу без изменений и быть готовым к тому, что в середине соревнований придётся выдать подсказку (так и вышло). Но с подсказкой в итоге одна команда всё же успешно доехала до флага &mdash; честь им и хвала!